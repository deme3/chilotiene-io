import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import { v4 as uuidv4 } from 'uuid';
import { JWT_SECRET } from '$env/static/private';
import type { Cookies } from '@sveltejs/kit';
import Session from '$lib/server/db/models/Session';
import type { IUser, IUserMethods } from '$lib/server/db/models/User';
import mongoose from 'mongoose';
import User from '$lib/server/db/models/User';
import { UserRole } from '../UserRole';
import ConfirmationToken, {
	type IConfirmationToken,
	type IConfirmationTokenMethods
} from './db/models/ConfirmationToken';
import * as mail from '$lib/server/mail';

export const COOKIE_NAME = 'AuthToken';

export type JWTData = {
	/**
	 * Standard JWT field: JWT ID, this is generated by the server upon login as
	 * a UUIDv4 string.
	 */
	jti: string;

	/**
	 * Standard JWT field: Subject, this is set to the Email Address of the user
	 * that is logging in.
	 */
	sub: string;

	/**
	 * Standard JWT field: Name, this is set to the full name of the user that is
	 * logging in.
	 */
	name: string;

	/**
	 * Standard JWT field: Issued At, this is set to the current timestamp in
	 * seconds.
	 */
	iat: number;

	/**
	 * Standard JWT field: Expiration, this is set to the timestamp in seconds
	 * when the JWT will expire.
	 */
	exp: number;
};

/**
 * Generates and signs JWT starting from the user data provided by the FBK APIs.
 *
 * @param user The user data from FBK APIs
 * @returns A JWT token string
 */
export function createJwt(user: IUser, altSecret?: string): string {
	if (process.env.NODE_ENV === 'test') {
		altSecret = process.env.TEST_JWT_SECRET;
	}
	const jwtId = uuidv4();
	const standardJWT = {
		sub: user.emailAddress,
		name: user.fullName,
		iat: Date.now() / 1000
	};

	return jwt.sign(standardJWT, altSecret ?? JWT_SECRET!, {
		jwtid: jwtId,
		expiresIn: '7d',
		algorithm: 'HS512'
	});
}

/**
 * Checks if a JWT is valid and returns it decoded if it is. If the JWT is not
 * valid, it will return `null`.
 *
 * @param token The JWT string to check
 * @returns The JWT decoded data object if valid, `null` otherwise
 */
export function checkJwtValidity(token: string, altSecret?: string): JWTData | null {
	if (process.env.NODE_ENV === 'test') {
		altSecret = process.env.TEST_JWT_SECRET;
	}
	try {
		const decoded = jwt.verify(token, altSecret ?? JWT_SECRET!, {
			algorithms: ['HS512']
		}) as JWTData;
		return decoded;
	} catch {
		return null;
	}
}

/**
 * This function performs directly the login operation by setting the JWT token
 * as cookie if the provided information is valid. If the user is not found in
 * the database, it will log a warning and return.
 *
 * @param emailAddress The user email address to log in
 * @param password The user password for the login
 * @param cookies The cookies object from the request
 * @param userAgent The user agent of the device that is requesting the login
 */
export async function performLogin(
	emailAddress: string,
	password: string,
	cookies: Cookies,
	userAgent: string
): Promise<boolean> {
	const user = await User.findOne({ emailAddress });

	if (!user) {
		console.warn(`Login attempt with non-existing user: ${emailAddress}`);
		return false;
	}

	if (!(await bcrypt.compare(password, user.password))) {
		console.warn(`Login attempt with invalid password for user: ${emailAddress}`);
		return false;
	}

	const jwtGenerated = createJwt(user);
	const jwtData = checkJwtValidity(jwtGenerated)!;

	console.log('Successful login for user:', emailAddress, 'with JWT ID:', jwtData.jti);
	await Session.createSession(jwtData, userAgent);
	cookies.set(COOKIE_NAME, jwtGenerated, {
		maxAge: 60 * 60 * 24 * 7,
		path: '/',
		sameSite: 'lax',
		secure: import.meta.env.MODE === 'production',
		httpOnly: true
	});

	return true;
}

export async function registerNewUser(
	fullName: string,
	emailAddress: string,
	password: string,
	role: UserRole = UserRole.User
): Promise<{
	user: mongoose.HydratedDocument<IUser, IUserMethods>;
	token: mongoose.HydratedDocument<IConfirmationToken, IConfirmationTokenMethods>;
}> {
	const hashedPassword = await bcrypt.hash(password, 10);
	if (typeof fullName !== 'string' || typeof emailAddress !== 'string') {
		throw new Error('Invalid user data provided.');
	}

	if (await User.exists({ emailAddress })) {
		throw new Error('User already exists');
	}

	const user = await User.create({
		fullName,
		emailAddress,
		password: hashedPassword,
		role,
		confirmed: false
	});

	const confirmationToken = await ConfirmationToken.createFor(user._id);
	await mail.sendConfirmationToken(user, confirmationToken);

	return { user, token: confirmationToken };
}

export type LoginInfo = {
	jwt: JWTData;
	user: mongoose.HydratedDocument<IUser, IUserMethods>;
};

/**
 * Checks if a user is logged in based on the cookies provided. If the user is
 * logged in, it will return the JWT data and the user data. If the user is not
 * logged in, it will return `false`.
 *
 * @param cookies Request Cookies
 * @returns Information related to the log in operation, or `false` if the login is invalid.
 */
export async function checkLogin(cookies: Cookies): Promise<LoginInfo | false> {
	const jwtCookie = cookies.get(COOKIE_NAME);
	if (!jwtCookie) return false;

	const jwtData = checkJwtValidity(jwtCookie);
	if (!jwtData) return false;

	// Offensive programming: if the JWT ID is not a string, it's invalid, but this should never happen.
	if (typeof jwtData.jti !== 'string') return false;

	const session = await Session.findOne({ sessionId: jwtData.jti });
	if (!session) return false;

	const user = await User.findById(session.userId);
	if (!user) {
		console.warn(
			`A valid session for user ${session.userId} was used, but their access had been revoked.`
		);
		return false;
	}

	return { jwt: jwtData, user };
}

/**
 * Terminates a session in the database.
 *
 * @param sessionId The session ID to terminate.
 */
export async function terminateSession(sessionId: string): Promise<void> {
	await Session.deleteOne({ sessionId });
}
